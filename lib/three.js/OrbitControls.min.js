THREE.OrbitControls = function (L, M) {
    this.object = L;
    this.domElement = (M !== undefined) ? M : document;
    this.enabled = true;
    this.target = new THREE.Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.25;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = false;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.enableKeys = true;
    this.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40};
    this.mouseButtons = {ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT};
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this.getPolarAngle = function () {return Q.phi};
    this.getAzimuthalAngle = function () {return Q.theta};
    this.saveState = function () {
        J.target0.copy(J.target);
        J.position0.copy(J.object.position);
        J.zoom0 = J.object.zoom
    };
    this.reset = function () {
        J.target.copy(J.target0);
        J.object.position.copy(J.position0);
        J.object.zoom = J.zoom0;
        J.object.updateProjectionMatrix();
        J.dispatchEvent(W);
        J.update();
        ac = e.NONE
    };
    this.update = function () {
        var ah = new THREE.Vector3();
        var af = new THREE.Quaternion().setFromUnitVectors(L.up, new THREE.Vector3(0, 1, 0));
        var ag = af.clone().inverse();
        var ae = new THREE.Vector3();
        var ad = new THREE.Quaternion();
        return function ai() {
            var aj = J.object.position;
            ah.copy(aj).sub(J.target);
            ah.applyQuaternion(af);
            Q.setFromVector3(ah);
            if (J.autoRotate && ac === e.NONE) {
                x(f())
            }
            Q.theta += i.theta;
            Q.phi += i.phi;
            Q.theta = Math.max(J.minAzimuthAngle, Math.min(J.maxAzimuthAngle, Q.theta));
            Q.phi = Math.max(J.minPolarAngle, Math.min(J.maxPolarAngle, Q.phi));
            Q.makeSafe();
            Q.radius *= F;
            Q.radius = Math.max(J.minDistance, Math.min(J.maxDistance, Q.radius));
            J.target.add(R);
            ah.setFromSpherical(Q);
            ah.applyQuaternion(ag);
            aj.copy(J.target).add(ah);
            J.object.lookAt(J.target);
            if (J.enableDamping === true) {
                i.theta *= (1 - J.dampingFactor);
                i.phi *= (1 - J.dampingFactor);
                R.multiplyScalar(1 - J.dampingFactor)
            } else {
                i.set(0, 0, 0);
                R.set(0, 0, 0)
            }
            F = 1;
            if (H || ae.distanceToSquared(J.object.position) > c || 8 * (1 - ad.dot(J.object.quaternion)) > c) {
                J.dispatchEvent(W);
                ae.copy(J.object.position);
                ad.copy(J.object.quaternion);
                H = false;
                return true
            }
            return false
        }
    }();
    this.dispose = function () {
        J.domElement.removeEventListener("contextmenu", D, false);
        J.domElement.removeEventListener("mousedown", V, false);
        J.domElement.removeEventListener("wheel", O, false);
        J.domElement.removeEventListener("touchstart", U, false);
        J.domElement.removeEventListener("touchend", N, false);
        J.domElement.removeEventListener("touchmove", X, false);
        document.removeEventListener("mousemove", a, false);
        document.removeEventListener("mouseup", aa, false);
        window.removeEventListener("keydown", j, false)
    };
    var J = this;
    var W = {type: "change"};
    var P = {type: "start"};
    var C = {type: "end"};
    var e = {NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4};
    var ac = e.NONE;
    var c = 0.000001;
    var Q = new THREE.Spherical();
    var i = new THREE.Spherical();
    var F = 1;
    var R = new THREE.Vector3();
    var H = false;
    var z = new THREE.Vector2();
    var s = new THREE.Vector2();
    var K = new THREE.Vector2();
    var d = new THREE.Vector2();
    var v = new THREE.Vector2();
    var q = new THREE.Vector2();
    var w = new THREE.Vector2();
    var b = new THREE.Vector2();
    var I = new THREE.Vector2();

    function f() {return 2 * Math.PI / 60 / 60 * J.autoRotateSpeed}

    function G() {return Math.pow(0.95, J.zoomSpeed)}

    function x(ad) {i.theta -= ad}

    function B(ad) {i.phi -= ad}

    var p = function () {
        var ad = new THREE.Vector3();
        return function ae(ag, af) {
            ad.setFromMatrixColumn(af, 0);
            ad.multiplyScalar(-ag);
            R.add(ad)
        }
    }();
    var A = function () {
        var ad = new THREE.Vector3();
        return function ae(ag, af) {
            if (J.screenSpacePanning === true) {
                ad.setFromMatrixColumn(af, 1)
            } else {
                ad.setFromMatrixColumn(af, 0);
                ad.crossVectors(J.object.up, ad)
            }
            ad.multiplyScalar(ag);
            R.add(ad)
        }
    }();
    var n = function () {
        var ae = new THREE.Vector3();
        return function ad(ah, ag) {
            var ai = J.domElement === document ? J.domElement.body : J.domElement;
            if (J.object.isPerspectiveCamera) {
                var af = J.object.position;
                ae.copy(af).sub(J.target);
                var aj = ae.length();
                aj *= Math.tan((J.object.fov / 2) * Math.PI / 180);
                p(2 * ah * aj / ai.clientHeight, J.object.matrix);
                A(2 * ag * aj / ai.clientHeight, J.object.matrix)
            } else {
                if (J.object.isOrthographicCamera) {
                    p(ah * (J.object.right - J.object.left) / J.object.zoom / ai.clientWidth, J.object.matrix);
                    A(ag * (J.object.top - J.object.bottom) / J.object.zoom / ai.clientHeight, J.object.matrix)
                } else {
                    console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
                    J.enablePan = false
                }
            }
        }
    }();

    function r(ad) {
        if (J.object.isPerspectiveCamera) {
            F /= ad
        } else {
            if (J.object.isOrthographicCamera) {
                J.object.zoom = Math.max(J.minZoom, Math.min(J.maxZoom, J.object.zoom * ad));
                J.object.updateProjectionMatrix();
                H = true
            } else {
                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
                J.enableZoom = false
            }
        }
    }

    function t(ad) {
        if (J.object.isPerspectiveCamera) {
            F *= ad
        } else {
            if (J.object.isOrthographicCamera) {
                J.object.zoom = Math.max(J.minZoom, Math.min(J.maxZoom, J.object.zoom / ad));
                J.object.updateProjectionMatrix();
                H = true
            } else {
                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
                J.enableZoom = false
            }
        }
    }

    function u(ad) {z.set(ad.clientX, ad.clientY)}

    function T(ad) {w.set(ad.clientX, ad.clientY)}

    function E(ad) {d.set(ad.clientX, ad.clientY)}

    function o(ae) {
        s.set(ae.clientX, ae.clientY);
        K.subVectors(s, z).multiplyScalar(J.rotateSpeed);
        var ad = J.domElement === document ? J.domElement.body : J.domElement;
        x(2 * Math.PI * K.x / ad.clientHeight);
        B(2 * Math.PI * K.y / ad.clientHeight);
        z.copy(s);
        J.update()
    }

    function ab(ad) {
        b.set(ad.clientX, ad.clientY);
        I.subVectors(b, w);
        if (I.y > 0) {
            r(G())
        } else {
            if (I.y < 0) {
                t(G())
            }
        }
        w.copy(b);
        J.update()
    }

    function l(ad) {
        v.set(ad.clientX, ad.clientY);
        q.subVectors(v, d).multiplyScalar(J.panSpeed);
        n(q.x, q.y);
        d.copy(v);
        J.update()
    }

    function Z(ad) {}

    function S(ad) {
        if (ad.deltaY < 0) {
            t(G())
        } else {
            if (ad.deltaY > 0) {
                r(G())
            }
        }
        J.update()
    }

    function h(ad) {
        switch (ad.keyCode) {
            case J.keys.UP:
                n(0, J.keyPanSpeed);
                J.update();
                break;
            case J.keys.BOTTOM:
                n(0, -J.keyPanSpeed);
                J.update();
                break;
            case J.keys.LEFT:
                n(J.keyPanSpeed, 0);
                J.update();
                break;
            case J.keys.RIGHT:
                n(-J.keyPanSpeed, 0);
                J.update();
                break
        }
    }

    function k(ad) {z.set(ad.touches[0].pageX, ad.touches[0].pageY)}

    function Y(ag) {
        if (J.enableZoom) {
            var af = ag.touches[0].pageX - ag.touches[1].pageX;
            var ae = ag.touches[0].pageY - ag.touches[1].pageY;
            var ai = Math.sqrt(af * af + ae * ae);
            w.set(0, ai)
        }
        if (J.enablePan) {
            var ad = 0.5 * (ag.touches[0].pageX + ag.touches[1].pageX);
            var ah = 0.5 * (ag.touches[0].pageY + ag.touches[1].pageY);
            d.set(ad, ah)
        }
    }

    function m(ae) {
        s.set(ae.touches[0].pageX, ae.touches[0].pageY);
        K.subVectors(s, z).multiplyScalar(J.rotateSpeed);
        var ad = J.domElement === document ? J.domElement.body : J.domElement;
        x(2 * Math.PI * K.x / ad.clientHeight);
        B(2 * Math.PI * K.y / ad.clientHeight);
        z.copy(s);
        J.update()
    }

    function y(ag) {
        if (J.enableZoom) {
            var af = ag.touches[0].pageX - ag.touches[1].pageX;
            var ae = ag.touches[0].pageY - ag.touches[1].pageY;
            var ai = Math.sqrt(af * af + ae * ae);
            b.set(0, ai);
            I.set(0, Math.pow(b.y / w.y, J.zoomSpeed));
            r(I.y);
            w.copy(b)
        }
        if (J.enablePan) {
            var ad = 0.5 * (ag.touches[0].pageX + ag.touches[1].pageX);
            var ah = 0.5 * (ag.touches[0].pageY + ag.touches[1].pageY);
            v.set(ad, ah);
            q.subVectors(v, d).multiplyScalar(J.panSpeed);
            n(q.x, q.y);
            d.copy(v)
        }
        J.update()
    }

    function g(ad) {}

    function V(ad) {
        if (J.enabled === false) {
            return
        }
        ad.preventDefault();
        switch (ad.button) {
            case J.mouseButtons.ORBIT:
                if (J.enableRotate === false) {
                    return
                }
                u(ad);
                ac = e.ROTATE;
                break;
            case J.mouseButtons.ZOOM:
                if (J.enableZoom === false) {
                    return
                }
                T(ad);
                ac = e.DOLLY;
                break;
            case J.mouseButtons.PAN:
                if (J.enablePan === false) {
                    return
                }
                E(ad);
                ac = e.PAN;
                break
        }
        if (ac !== e.NONE) {
            document.addEventListener("mousemove", a, false);
            document.addEventListener("mouseup", aa, false);
            J.dispatchEvent(P)
        }
    }

    function a(ad) {
        if (J.enabled === false) {
            return
        }
        ad.preventDefault();
        switch (ac) {
            case e.ROTATE:
                if (J.enableRotate === false) {
                    return
                }
                o(ad);
                break;
            case e.DOLLY:
                if (J.enableZoom === false) {
                    return
                }
                ab(ad);
                break;
            case e.PAN:
                if (J.enablePan === false) {
                    return
                }
                l(ad);
                break
        }
    }

    function aa(ad) {
        if (J.enabled === false) {
            return
        }
        Z(ad);
        document.removeEventListener("mousemove", a, false);
        document.removeEventListener("mouseup", aa, false);
        J.dispatchEvent(C);
        ac = e.NONE
    }

    function O(ad) {
        if (J.enabled === false || J.enableZoom === false || (ac !== e.NONE && ac !== e.ROTATE)) {
            return
        }
        ad.preventDefault();
        ad.stopPropagation();
        J.dispatchEvent(P);
        S(ad);
        J.dispatchEvent(C)
    }

    function j(ad) {
        if (J.enabled === false || J.enableKeys === false || J.enablePan === false) {
            return
        }
        h(ad)
    }

    function U(ad) {
        if (J.enabled === false) {
            return
        }
        ad.preventDefault();
        switch (ad.touches.length) {
            case 1:
                if (J.enableRotate === false) {
                    return
                }
                k(ad);
                ac = e.TOUCH_ROTATE;
                break;
            case 2:
                if (J.enableZoom === false && J.enablePan === false) {
                    return
                }
                Y(ad);
                ac = e.TOUCH_DOLLY_PAN;
                break;
            default:
                ac = e.NONE
        }
        if (ac !== e.NONE) {
            J.dispatchEvent(P)
        }
    }

    function X(ad) {
        if (J.enabled === false) {
            return
        }
        ad.preventDefault();
        ad.stopPropagation();
        switch (ad.touches.length) {
            case 1:
                if (J.enableRotate === false) {
                    return
                }
                if (ac !== e.TOUCH_ROTATE) {
                    return
                }
                m(ad);
                break;
            case 2:
                if (J.enableZoom === false && J.enablePan === false) {
                    return
                }
                if (ac !== e.TOUCH_DOLLY_PAN) {
                    return
                }
                y(ad);
                break;
            default:
                ac = e.NONE
        }
    }

    function N(ad) {
        if (J.enabled === false) {
            return
        }
        g(ad);
        J.dispatchEvent(C);
        ac = e.NONE
    }

    function D(ad) {
        if (J.enabled === false) {
            return
        }
        ad.preventDefault()
    }

    J.domElement.addEventListener("contextmenu", D, false);
    J.domElement.addEventListener("mousedown", V, false);
    J.domElement.addEventListener("wheel", O, false);
    J.domElement.addEventListener("touchstart", U, false);
    J.domElement.addEventListener("touchend", N, false);
    J.domElement.addEventListener("touchmove", X, false);
    J.domElement.addEventListener("keydown", j, false);
    this.update()
};
THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
Object.defineProperties(THREE.OrbitControls.prototype, {
    center: {
        get: function () {
            console.warn("THREE.OrbitControls: .center has been renamed to .target");
            return this.target
        }
    },
    noZoom: {
        get: function () {
            console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.");
            return !this.enableZoom
        },
        set: function (a) {
            console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.");
            this.enableZoom = !a
        }
    },
    noRotate: {
        get: function () {
            console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.");
            return !this.enableRotate
        },
        set: function (a) {
            console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.");
            this.enableRotate = !a
        }
    },
    noPan: {
        get: function () {
            console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.");
            return !this.enablePan
        }, set: function (a) {
            console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.");
            this.enablePan = !a
        }
    },
    noKeys: {
        get: function () {
            console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.");
            return !this.enableKeys
        },
        set: function (a) {
            console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.");
            this.enableKeys = !a
        }
    },
    staticMoving: {
        get: function () {
            console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.");
            return !this.enableDamping
        },
        set: function (a) {
            console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.");
            this.enableDamping = !a
        }
    },
    dynamicDampingFactor: {
        get: function () {
            console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.");
            return this.dampingFactor
        },
        set: function (a) {
            console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.");
            this.dampingFactor = a
        }
    }
});